EGP RESTful API v1 specification.

//TODO Add pagination to all the collections, remove PHP session dependency
//TODO Add request fields filtering
//TODO Add facebook hybrid auth
//TODO Add client side or async server side data validation to login/create user scenario
//TODO remove all old authentication classes
===============================
MAKING API REQUESTS

For security reasons all the interactions are performed via HTTPS.
To unify things, all the API requests and responses data is represented in the form of JSON objects.
In the following spec we'll refer to request JSON object as "REQUEST" and response JSON object as "RESPONSE".

REQUEST object should be the body of request for all the HTTP request methods except GET.
In case of GET request, set GET request parameter "request" of your URL to the url encoded REQUEST value.
Example: https://learzing.com/api/user?request={%20userid:%20%2213rfefv39fj3f48j9838&#&#&"}

RESPONSE object is always passed in the body of your API response and has the following layout:
{
  status: STATUS - defines status of requested operation. See STATUS values description below.
  texts: [String] List of human readable status explanation strings in current user's locale or in English.
  data: service dependent field defined in documentation as RETURNS.
}
STATUS values:
- "SUCCESS": operation is completed successfully.
- "AUTHORIZATION_FAILED": returned when current user doesn't have sufficient permissions
   to perform requested operation.
- "INVALID_ARGUMENT": argument passed to operation has invalid value.
- "INTERNAL_ERROR": internal server error occured.

To perform authorization of your API request you need to supply access token in HTTP header:
"Authorization: <token_type> <access_token>"
or HTTPS cookie "LEARZING_API_TOKEN" which contains <access_token>
You obtain <token_type> and <access_token> from GET request to service auth/token.

+++++++++++++++++++++++++++++++
API SERVICES DESCRIPTION
URLs of all API services have the following form: /api/<service_name>

===============================
service_name: auth/token
API USER AUTHENTICATION SERVICE
HTTP methods:
GET: get AccessTokenInfo object to use for authorization of API requests and authentication
    as user with email @email and password @password. @client_id is your app id which you got
    from Learzing.
    REQUEST: { email: String, password: String, client_id: String }
    RETURNS: AccessTokenInfo

DELETE: revoke (make invalid) @access_token. Also pass your client's @client_id which you got
    from Learzing.
    REQUEST: { access_token: String, client_id: String }

Javascript types:
AccessTokenInfo: { access_token: String, token_type: String }
===============================
service_name: user
HTTP methods:
GET: get User object with id @userid and all the information avaliable for current user
    REQUEST: { userid : String }
    RETURNS: User
	
POST: register new @user object with password @password. No access token is needed to perform the action.
    After successful creation of user, get access token using API authentication endpoint.
    REQUEST: { User user, String password } 

PUT: replace current user object with @user object supplied (update scenario)
    REQUEST: { User user }

DELETE (): not implemented

Javascript types:
User: { id: string, email: string, name: string, surname: string, is_online: "true"|"false", role: UserRole }
UserRole: "customer" or ...
===============================
service_name: friends
HTTP methods:
GET: get list of friends visible to current user of user with id @userid
    REQUEST : { userid : String }
    RETURNS: [User]

POST: add new friend with id @userid to current user's friend list
    REQUEST : { userid : String }

PUT: not implemented

DELETE:  delete current user's friend with id @userid
    REQUEST : { userid : String }

===============================
service_name: messaging
HTTP methods:
GET: get list of messages with sequential number from @start to @end in conversation of current user and user with id @userid.
    @start: message sequential number starting from 1
    @end: message sequential number
    You can use 'LAST-x' value for @start and @end, where x is some number to perform selection of messages relative to the last message.
    REQUEST: { userid : String, start : String, end: String }
    RETURNS: [Message]

POST: send message with body @text from current user to user with id @userid
    REQUEST: { userid : String, text : String }

PUT: not implemented

DELETE: not implemented

Javascript types:
Message: { from: userid, to: userid, date: string/date JS type, time: string/time JS type: body: string }
===============================
service_name: search
HTTP methods:
GET: Get search results for query @query looking for objects of type @object_type.
    REQUEST: { query : String, object_type = ObjectType | "all" } 
    RETURNS: { search_results: [ SearchResult ] }

Javascript types:
SearchResult: { object_type : ObjectType, object : Object }
ObjectType: "user" | ...
Object : User | ...
=============================